1）String、StringBuffer、StringBuilder类（Begin43、44）：
	String类：
		String没有子类；描述字符串事物
		常见操作：见Begin43
		（包含“字符数组和字符串的互换”、“字节数组和字符串的互换”、“将基本数据类型转换成字符串”）
	StringBuffer：
		字符串缓冲区，装数据的容器，但此容器会将得到的数据进行反转，可以直接操作多个数据类型，
		此容器中提供了一种添加的方法，即算一个数往容器里加一个数
		其长度是可变化的；可以直接操作多个数据类型；最终会通过toString方法变成字符串
		StringBuffer是线程同步（多线程使用），是线程不同步的，但是线程安全的
     	StringBuilder：线程不同步（单线程使用），不是是线程安全的，
		但StringBuilder在单线程中的性能比StringBuffer高，
		以后开发建议使用StringBuilder。
2）封装（Begin7）：
	每个对象都包含它能进行操作所需要的所有信息，这个特性就是封装；
	所以对象不必依赖其他对象来完成自己的操作；
	private修饰类中的成员，私有仅在本类中有效，
	作用是防止该类的代码和数据被外部类定义的代码随机访问，
	访问私有类中成员的方式：set和get
3）this关键字（Begin9）：
	当定义类中功能（函数）时，该函数内部要用到调用该类中的对象时，用this来表示这个对象，
	（但凡本类功能内部使用到了本类对象时，都用this表示），
	this语句只能定义在构造函数的第一行，因为初始化要先执行，
	变量出现同名的情况时一定要加this，未出现同名情况时this可省略
4）static关键字（Begin10）：
	修饰符，用于修饰成员（成员变量，成员函数），
	当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，还可以直接被类名调用，
	调用方式是：类名 . 静态成员，
	静态变量生命周期长，对内存消耗大，不建议过多定义，
	静态方法只能访问静态成员,非静态方法可以访问静态成员和非静态成员，
	静态方法中不可以定义this，super关键字，因为静态优先于对象存在，
	父类中的静态方法不会被子类覆盖
	什么时候使用静态（静态变量，静态函数）：
		静态变量（类变量）：当对象中出现共享数据（值）时；对象的特有数据要定义成非静态存在于堆内存中，
		静态函数：当功能内部没有访问到非静态数据（对象的特有数据）时，该功能可以定义成静态的
5）静态代码块（Begin11）：
	随着类的加载而执行，且只执行一次,并优先于主函数执行，用于给类进行初始化，
	static{
	         执行语句；
	}
	先运行父类中的静态代码块，再运行子类中的静态代码块，再运行main方法（main函数定义在子类中）；
	先运行父类中的静态代码块，再运行子类中的静态代码块，再运行main方法（main函数定义在父类中）
6）继承extends（Begin13）：
	让类与类之间产生了关系（必须是类与类之间有所属关系才可以继承），有了这种关系，才有了多态的特性，
 	判断所属关系：子类具备父类中所有的功能，子类中也可以定义父类中没有的方法（子类特有的）。
	Java支持多层基础，即：C extends B ，B extends A ，也就是一个继承体系，不支持多继承（extends A，B）；
	父类中有一个对象是私有（private）的时，此对象不能被子类继承，但编译可以通过，
	但父类中有对象用public修饰，而子类此对象中没有用public修饰时，编译不通过；
	子类覆盖父类，必须保证子类的权限大于父类，才可以覆盖，否则编译失败； 
	子父类出现后，类中成员（变量，函数，构造函数）的特点：
		1.变量：当子类中出现非私有的同名成员变量时，
			子类要访问本类中的变量，用this
			子类要访问父类中的变量，用super
		2.函数：当子类出现和父类一摸一样的函数时，
			当子类的对象调用该函数时，会运行子类函数的内容
			如同父类的函数被覆盖一样
			这种情况是函数的另一个特性：重写（覆盖）
		3.构造函数：（子父类中的构造函数不可能一模一样）
			在对子类对象进行初始化时，父类的构造函数也会执行，
			这是因为子类的构造函数默认第一行有一条隐式的语句super();
			super(); ：会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super();	
7）抽象类abstract和抽象方法（Begin14、15）：
	当多个类中出现相同功能，但功能主体不同时，可一进行向上抽取，这时，只抽取功能定义，而不抽取功能主体，
	抽象类不可以用new关键字来创建对象，
	抽象方法一定定义在抽象类中，抽象方法和抽象类都必须被abstract关键字修饰，
	抽象类中的抽象方法方法要被使用，必须由子类复写了所有抽象方法后，建立子类对象调用；
	抽象类中也可以有非抽象方法；
	抽象方法必须是被子类重写的方法（如果不重写，那抽象出来有什么意义）；
8）构造函数（构造方法、构造器）（Begin15）：
	是一种特殊的函数。其主要功能是用来在创建对象时初始化对象，即为对象成员变量赋初始值，
	this语句只能定义在构造函数的第一行，因为初始化要先执行，
	构造方法的方法名必须与类名相同，
	构造方法没有返回值类型，可以有return（一般不用）但是不能有返回值，在这里只是表示结束，并不是返回的表示，
	构造方法可以重载，以参数的个数，类型，顺序
	构造器重载：
		同一个类里有多个构造器，多个构造器的形参列表不同，称为构造器的重载；
9）final关键字：
	final变量：
		被final修饰的变量一旦赋值后，不能被重新赋值，
		被 final 修饰的实例变量必须显式指定初始值，			
		final 修饰符通常和 static 修饰符一起使用来创建类常量，
	final方法：
		声明 final 方法的主要目的是防止该方法的内容被修改，
		类中的 final 方法可以被子类继承，但是不能被子类修改，
	final类：
		final 类不能被继承，没有类能够继承 final 类的任何特性
	当在描述事物时，一些数据的值是固定的，这是为了增强阅读性，都给这些值起个名字，方便阅读，
	而这个值不需要改变，所以加上final修饰。作为常量，常量的书写规范为：所有字母都大写，
	如果由多个单词组成，单词间通过 _ 连接。
10）接口：（Begin17）
	Java中一个抽象类型，抽象方法的合集，通常以interface来声明；
	一个接口可以有多个方法，这些方法都必须是抽象方法；
	接口可以被实现无法被实例化，一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；
	接口支持多继承，一个接口可以继承另一个接口；
	接口是不可以创建对象的，因为有抽象方法；
	需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化，否则子类时是一个抽象类；
	接口跟类不一样：
		类描述对象的属性和方法，接口则包含类要实现的方法；
		除非实现接口的类是抽象类，否则该类要定义接口中的所有方法；
	接口中的成员修饰符是固定的：
		成员常量：public static final
		成员函数：public abstract
	重写接口中声明的方法时，需要注意：
		类在实现接口的方法时，不能抛出强制性异常，
		只能在接口中，或者继承接口的抽象类中抛出该强制性异常；
		类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；
		如果实现接口的类是抽象类，那么就没必要实现该接口的方法。
11）多态（Begin18、19、20）：
	多态表示不同的兑现够可以执行相同的动作，但要通过他们自己的代码来执行；
	子类以父类的身份出现，子类在工作时以自己的代码来实现，子类以父类的身份出现时，子类特有的方法不能使用；
	多态的实现方式：继承、接口（方法重写）；
	Animal c3 = new Cat();
	多态的前提：
		类与类之间有关系，要么继承，要么实现（接口）；
		通常还有一个前提：存在覆盖；
	成员函数在多态调用时，编译看左边，运行看右边；
	多态中的成员变量，无论编译和运行，都参考左边（引用型变量所属的类）；
	在多态中，静态成员函数的特点：无论编译和运行，都参考左边；
	多态的应用：
		类型提升，把猫提升为了动物，称为向上转型；
		强制转换，强制将父类的引用转换为子类的类型，称为向下转型；
		不能将父类的类型转为子类类型；
		多态自始至终都是子类对象在做着变化；
	使用大大的提高了程序的扩展性，但只能使用父类的引用访问父类中的成员；
12）Object类（Begin21）：
	所有对象的直接或间接父类，该类中定义的是所有对象都具备的功能，
	方法：
		getClass()方法返回该对象的运行时类，
		toString()方法返回该对象的字符串表示，
		hashCode()返回该对象的hashCode值，
		equals比较的是地址，等于就是true，不等于就是false
13）内部类（内置类、嵌套类）（Begin22、23）：
	内部类可以直接访问外部类中的成员：外部类名.this（外部类要访问内部类，必须先建立内部类对象），
	内部类成员可以直接访问外部类的私有数据，但此私有数据必须是静态的，
	外部类不能访问内部类的实现细节（如内部类的成员变量），
	内部类只有在外部类中才有意义（如Inner只有在Outer中才有意义），
	内部类只有外部类能访问（如Inner只能被Outer访问，而且还不能访问Inner的实现细节），
	Outer.Inner inn = new Outer().new Inner();
	内部类定义在局部时不可以被成员修饰符修饰。
14）匿名内部类（Begin24、25）：
	匿名内部类适合于创建那些仅需要使用一次的类，
	定义匿名内部类的前提：内部类必须是继承一个类或者实现接口，
	匿名内部类的格式： new  父类或者接口() {定义子类的内容}，
	匿名内部类中的定义的方法最好不要超过3个
15）修饰符：
	成员变量修饰符：default、private、public、protected、final、static，
	方法修饰符：public、private、protected、final、static
16）@Override（重写）（Begin24）：
	重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变，
	如果想重写父类的方法，比如toString()方法的话，在方法前面加上@Override 系统可以帮你检查方法的正确性，
	重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常，
	在面向对象里，重写意味着可以重写任何现有方法，
	构造方法不能被重写，声明为final的方法不能被重写，声明为static的方法只能够被再次声明不能被重写，
	重写后方法的访问权限不能比父类中被重写的方法的访问权限更低（不能做出更严格的访问限制），
	父类的成员方法只能被它的子类重写，
	重写不能抛出新的异常，
17）super关键字：
	当需要在子类中调用父类的被重写方法时，要使用super关键字，
18）@Overload（重载）：
	重载是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同，
	最常用的地方就是构造器的重载，
	重载的异常和访问都可以修改，
	重写和重载是Java多态性的不同体现，
	重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，
	重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法
19）异常机制（Begin26-31）：
	异常就是程序在运行时出现不正常情况，
	所有的异常类是从 java.lang.Exception 类继承的子类，Exception和Error都是是Throwable类的子类，
	一个方法可以声明多个异常，多个异常之间用逗号隔开，
	异常处理：
		try{
     		     需要被检测的代码；
 		 } catch(异常类  变量){
  		     处理异常的代码的处理方式；
  		} finally{
     		     一定会执行的语句；
  		}
	三种结合方式：try-catch；try-finally；try-catch-finally，
	多重捕获块（catch块）：
		在 try 语句后面添加任意数量的 catch 块，如果保护代码中发生异常，异常被抛给第一个 catch 块，
		若抛出异常的数据类型与 ExceptionType1匹配，则它在这就会被捕获，
		如果不匹配，则被传递给第二个catch 块，
		如此，直到异常被捕获或者通过所有的 catch 块
	异常处理--自定义异常：
		自定义异常信息：
			子类只要在构造时，将异常信息通过super语句传递给父类，
			就可以直接通过getMessage方法获取自定义的异常信息，
		自定义异常：
			自定义类必须是继承Exception，这样自定义类才具有可抛性，
		异常在子父类中的体现：
			子类在覆盖父类时，如果父类的方法抛出异常，
			那么子类的覆盖方法只能抛出父类的异常或者该异常的子类；
			如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集；
			如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常；
			如果子类方法发生了异常，就必须要进行try处理，绝对不能抛，
20）包package（Begin32）：
	包的作用：对类文件进行分类管理；给类提供多层命名空间，
	包写在程序文件的第一行；类名的全称是  包名.类名；包也是一种封装形式，
	包与包之间进行访问，被访问的包中的类以及类中的成员，需要public修饰，
	不同包中的子类还可以直接访问父类中被protected权限修饰的成员，
	包与包之间可以使用的权限只有两种：public 和 protected
21）成员变量和局部变量：
	成员变量是定义在类里的变量，局部变量是定义在方法里的变量；
	成员变量分为类变量和实例变量两种：
		有static修饰的是类变量，没有static修饰的是实例变量，
		类变量的作用域与这个类的作用范围相同，实例变量的作用域与对应的实例的生存范围相同，
		其实类变量的作用域比实例变量的作用域更大
22）线程（Begin33-42）：
	线程与进程：
		进程是一个正在执行中的程序，线程是进程中独立的控制单元，一个进程中至少有一个线程，
		Java VM 启动的时候会有一个进程Java.exe，该进程中至少有一个线程负责Java程序的执行，
		而且这个线程运行的代码存在于main方法中，该线程称之为主线程；
	多线程：
		用多线程的目的只有一个，就是更好的利用CPU的资源；
	自定义线程：
		继承Thread：
			定义类继承Thread，
			复写Thread类中的run方法（目的：将自定义的代码存储在run方法中，让线程运行），
			该方法有两个作用：启动线程，调用run方法，
			start方法：开启线程并运行（其实是使线程进入就绪状态）；
		实现Runnable接口：
			定义类实现Runnable接口，
			覆盖Runnable接口中的run方法，将线程要运行的代码存放在该run方法中，
			通过Thread类建立线程对象，
			将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数，
			调用Thread类的start方法开启线程并调用Runnable接口子类的run方法；
		实现方式和继承方式的区别：
			实现方式的好处：避免了单继承的局限性，在定义线程时，建议使用实现方式，
			继承Thread：线程代码存放在Thread子类的run方法中，
			实现Runnable：线程代码存放在接口的子类的run方法中；
	多线程的特性---随机性：
		每次运行结果都不同，因为多个线程都获取CPU的执行权，CPU执行到谁，就运行谁，
		在某一个时刻，只能有一个程序在运行（多核除外），
		CPU在做着快速的切换，以达到看上去是同时运行的效果，
		可以形象的把多线程的运行形容为互相抢夺CPU的执行权，谁抢到谁执行，执行多长时间取决于CPU；
	线程同步：
		就是让一个线程执行完了再执行其他线程的方法
		同步代码：
			使用同步监视器的通用方法就是同步代码块；
			需要同步的原因：
				当多条语句在操作同一线程共享数据时，
				一个线程对多条语句只执行了一部分，还没有执行完，
				另一个线程就参与进来执行，导致共享数据的错误，
				所以就需要阻止两个线程对同一个资源进行并发访问；
			（需要同步的代码：需要共享操作的语句）
		  	synchronized(对象){
			 	需要被同步的代码；}
			同步的前提：必须要有两个或多个线程，必须是多个线程使用同一个锁，
			同步的好处：解决了多线程的安全问题，同步的弊端：多个线程都需要判断锁，较为消耗资源；
		同步函数：
			被synchronized修饰的方法，也是用于解决两个线程对统一资源进行并发访问的情况的；
		同步锁：
			也是用于解决两个线程对统一资源进行并发访问的情况的，每次只能有一个线程对lock对象加锁
			有ReadWriteLock（读写锁）和ReentrantLock（可重入锁）实现类
	线程阻塞、死锁、死亡：
		线程阻塞：
			会发生阻塞的情况：
			1.线程调用sleep()方法主动放弃所占用的CPU资源；
			2.线程调用了一个阻塞式IO方法，在该方法返回之前，线程被阻塞；
			3.线程试图获得一个同步监视器，但该同步监视器正在其他线程所持有；
			4.线程正在等待某个通知notify()；
			5.程序调用了线程的suspend()方法将该线程挂起（这个方法容易导致死锁，尽量避免使用）；
			解除阻塞：
			1.调用sleep()方法已经过了指定时间；
			2.线程调用的阻塞式IO方法已经返回；
			3.线程成功地获得了试图取得的某个同步监视器；
			4.线程正在等待某个通知时，其他线程发出了一个通知；
			5.处于挂起状态的线程被调用了resume()恢复方法；
		线程死锁：
			两个对象互相等待对方释放同步监视器时会发生死锁，
			此时整个线程处于阻塞状态，无法运行
			线程对象的isAlive()方法：若线程处于新建或死亡则返回false，就绪运行阻塞时返回true；
			sleep()方法需要继承Thread类
		线程死亡：
			1.run()方法或者call()方法运行结束，线程就会进入死亡状态；
			2.线程抛出一个未捕获的Exception或Error
			3.直接调用该线程的stop()方法结束该线程（该方法容易导致死锁，不推荐使用）
	线程间通讯：
		传统线程通讯：
			wait();让当前线程等待
			notify();唤醒在此同步监视器上等待的单个线程
			notifyAll();唤醒在此同步监视器上等待的所有线程
			等待和唤醒必须是对同一个锁做的，而锁可以是被任意对象调用的方法定义在Object类中
			有个问题：只用notify容易出现只唤醒本方线程的情况，会导致程序中的所有线程都等待
			所以使用notifyAll；
		使用Condition控制线程通讯：
			当使用Lock对象来保证同步时，
			可使用Condition（类）让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，
			Condition也可以唤醒其他正在等待的线程；
			Condition类提供了三个方法：
			await()方法：类似于隐式同步监视器上的wait()方法，
			signal()方法：唤醒在此Lock对象上等待的单个线程，
			signalAll()方法：唤醒在此Lock对象上等待的所有线程
	停止线程：
		开启多线程运行，代码通常是循环结构，
		只要控制住循环，就可以让run方法结束。也就是让线程结束
	控制线程：
		Jion线程：
			当A线程执行到了B线程的.join()方法时，A线程就会等待，等B线程都执行完，A线程才会执行
			join可以用来临时加入线程执行
		后台线程：
			 setDaemon()，所有前台线程执行完后后台线程会自动关闭，
			当后台线程被关闭时，资源的回收是立即的，不考虑后台线程是否执行完成，正在执行中也立即被终止，
			后台线程一般用于处理时间较短的任务，比如处理客户端发过来的请求信息
		线程睡眠：sleep()
			让当前正在执行的线程等待一段时间，这段时间具体多长看括号里的数字
		线程让步：yield()
			让当前正在执行的线程暂停，进入就绪状态（而非阻塞），
			线程调用yield()方法后将执行机会让给优先级相同的其它线程
			线程优先级：所有的线程默认优先级都是5（共10级）
23）基本数据类型对象包装类：
	byte     Byte；		short    short；
	int      Integer；		long     Long；
	boolean  Boolean；		float    Float；
	double   Double；		char     Character；
24）集合框架（Begin46）：
	集合类出现的原因是：为了保存数量不确定的数据或具有映射关系的数据
	集合里只能保存对象（数组里可以保存数据和对象的引用）
	集合类的根接口：Collection 和 Map（还有个Iterator是用来遍历Collection中的元素的）
	 Collection的子接口：Set、Queue、List
	Set接口下的HashSet、TreeSet；List接口下的ArrayList、LinkedList；Queue接口下的ArrayDeque，这5个子类划重点
	Map接口下的HashMap和TreeMap划重点
	 Java集合大致分为四种体系（是集合也是接口）：
		（1）Set：无序、不可重复的序列
		（2）List：有序、可重复的序列
		（3）Map：具有映射关系的集合
		（4）Queue：队列集合
	集合之Iterator（Begin46）：
		Iterator必须依附于Collection对象
		Iterator是把集合元素的值赋给了迭代变量，所以修改迭代变量并不会影响到集合元素
		只有Iterator的remove()方法删除上一次next()返回的集合元素时Collection集合里的元素才会被改变
	集合之遍历集合（Begin46）：
		使用Lambda表达式遍历集合；使用Iterator遍历集合；
		使用Lambda表达式遍历Iterator；使用foreach循环遍历集合元素；
		 使用Predicate操作集合；使用Java新增的Stream（通用的流接口）操作集合
	集合之Set（CollectionSet）：
		Set里的元素是无序不重复的；
		HashSet：底层数据结构是哈希表，线程是非同步的，可以放入null，但只能放入一个null；
		TreeSet：可以对Set集合中的元素进行排序，底层数据结构是二叉树，不允许放入null值
	集合之List（CollectionList）：
		List里的元素是有序的，元素可以重复，因为该集合体系有索引；
		ArrayList：底层的数据结构使用的是数组结构；特点：查询速度很快，但是增删速度稍慢，线程不同步；
		LinkedList：底层使用的是链表数据结构；特点：增删速度很快，查询稍慢；
		Vector：底层使用的是数组数据结构，特点：线程同步（被ArrayList替代了）；
		List集合特有的迭代器：ListIterator是Iterator的子接口；
	集合之Map（Map）：
		Map是一个接口，但不是collection的子接口或者实现类；
		HashTable：底层是哈希表数据结构，不可以存入null键null值，该集合是线程同步的，jdk1.0效率低；
		HashMap：底层是哈希表数据结构，允许使用null键和null值，该集合是不同步的，jdk1.2效率高；
		TreeMap：底层是二叉树数据结构，线程不同步，可以用于给map集合中的键进行排序
25）集合与数组的互相转换（Arrays）：
	asList：将数组变成List集合
		把数组变成集合的好处：可以使用集合的方法来操作数组中的元素，
		注意：将数组变成集合，不可以使用集合的增删方法，因为数组的长度是固定的，
		如果数组中的元素都是对象，那么变成集合时，数组中的元素就直接转成集合中的元素，
		如果数组中的元素都是基本数据类型，那么会将该数组作为集合中的元素存在 ；
	toArray：将集合变成（指定类型的）数组（Collection接口中的toArray方法）
		1.指定类型的数组到底定义多长呢？
		当指定类型的数组长度小于了集合的size，那么该方法内部会创建一个新的数组，长度为集合的size；
		当指定类型的数组长度大于了集合的size，就不会新创建了数组，而是使用传递进来的数组；
		所以应当创建一个长度刚刚好的数组；
		2.为什么要将集合变数组？
		为了限定对元素的操作，不需要进行增删了。
26）泛型（Begin47-49）：
	为什么会有泛型：
		把一个对象“丢进”集合里，集合就会“忘记这个对象的数据类型，
		再次取出该对象时，该对象的编译类型就变成了Object类型，而泛型的出现，正事为了解决该问题；
		具体有：泛型类、泛型接口、类型通配符、泛型方法；
	泛型格式：通过< > 来定义；
		Java允许在构造器后不需要完整的泛型信息只给出一对尖括号<>即可，
		如：List<String> str = new ArrayList<>;这种语法被称为泛型的“菱形”语法；
	泛型的好处：
		将运行时期出现的问题ClassCaseException转移到了编译时；避免了强制转换的麻烦;
	什么时候定义泛型：
		当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在定义泛型来完成扩展
	【注】：
		静态方法不可以访问类上定义的泛型，如果静态方法的应用的数据类型不确定，可以将泛型定义在方法上;
		定义构造器时不能使用Utils<QQ>,只能使用Utils，调用该构造器时可是使用Utils<QQ>;
		不论泛型的实际类型参数是什么，他们在运行时总有相同的类（class）;
		并不是只有集合类才可是使用泛型声明，其他类也可声明泛型;
		String是的子类型，但List<String>并不是<Object>的子类
	泛型的实质：
		允许在定义接口、类时声明类型形参，
		类型形参是在整个接口、类体内可当成类型使用，
		几乎所有课使用普通类型的地方都可以使用这种类型形参;
	类型通配符<?>:
		意思是元素类型未知的***；
		类型通配符适用于任何支持泛型声明的接口和类；
		对public static void printCall1(ArrayList<? extends Person3> al){}
			意思是元素类型未知的ArrayList是Person3的子类；凡是Person3的子类都可以传入，
			但如果子类的类型未知，同样也不能把任何对象添加到这种集合中；
			带通配符的ArrayList仅表示它是各种泛型ArrayList的父类，并不能把元素加入到其中；
			（因为集合ArrayList集合中元素的类型是未知的，所以无法向此集合中添加对象）
			此种语句是类型通配符的上限
		对public static <T> T  copy(Collection<? super T> dest,Collection<T> src){}
			意思：？类型是T类型的本身或者T类型的父亲
	泛型方法：eg：static <T> void fromArrayToCollection(T[] a,Collection<T> c){}
		该泛型方法中带一个T类型形参（T类型的数组和数据类型是T类型的集合）；
		方法中声明的形参只能在该方法里使用，而接口、类声明中定义的类型形参可以在整个接口、类中使用；
		方法中的泛型参数无需显式传入实际类型参数；
		
	泛型构造器：
		Java允许在构造器签名中声明类型形参，这种构造器叫泛型构造器；
		//泛型构造器		
		public <T> Foo(T t){
       		       System.out.println(t);
   		}
27）输入/输出（Begin50-59）：
	在java.nio包下主要包括输入、输出两种IO流；
	每种输出、输出流又可分为字节流和字符流两大类；
	Java对象的序列化机制：使用序列化机制可把内存中的Java对象转换成二进制字节流；
	字节流（Begin50）：
		字节流以字节为单位来处理输入、输出操作；
		字节流的两个基类：InputStream、OutputStream；
	字符流（Begin50）：
		字符流以字符为单位来处理输入、输出操作；
		字符流的两个基类：Reader
				     |――BufferedReader
				     |――FileReader
				Writer
				     |――FileWriter
				     |――BufferedWriter
		InputStream和Reader是所有输入流的基类，OutputStream和Writer是所有输出流的基类；
	字节流和字符流的区别（Begin51）：
		通常来说，字节流的功能比字符流强大，因为计算机里所有数据都是二进制的，而字节流可以处理二进制文件；
		如果用字节流来处理文本文件，则需用合适的方式把字节转换成字符，这就增加了编程的复杂度；
		所以通常有如下规则：
		如果进行输入/输出的文件是文本内容，则考虑使用字符流；
		如果进行输入/输出的文件是二进制内容，则考虑使用字节流。
	File类（Begin50）：
		File类是java.io包下代表与平台无关的文件和目录，
		如果希望在程序中操作（新建、删除、重命名）文件和目录都可以通过File类来完成，
		File不能访问文件内容本身（但是可以获取文件内容的长度），只有输入输出流可以访问文件本身；
		File类中delete()方法和deleteOnExit()方法的区别：
			当调用delete()方法时，直接删除文件，不管该文件是否存在，一经调用立即执行；
			当程序运行结束，JVM终止时调用deleteOnExit()方法实现删除操作，
			即该方法是将删除的命令缓存了一下，到服务停止的时候再进行操作。
	IO流（Begin50）：
		即输入、输出流，主要包括字节流和字符流；
		Java的序列化机制：使用序列化机制可以把内存中的Java的对象转变成二进制字节流；
		输入流：只能从中读取数据，不能向其中写入数据；输出流：只能向其中写入数据，不能向其中读入数据；
		字节流操作的数据单位是8位的字节，字符流操作的数据是16位的字符；
		（按照流的角度可分为节点流和处理流，具体见后面）
	处理流printStream（Begin51）：
		功能：可以隐藏底层设备上结点流的差异，并对外提供更加方便的输入/输出方法；
		使用处理流的思路：使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，
		让节点流与底层的I/O设备、文件交互；
		（在创建处理流是传入一个节点流作为构造器参数即可）。
	结点流（Begin51）：
		字节流以字节数组为节点，字符流以字符数组为节点；
	转换流（Begin51）：
		用于将字节流转换成字符流；
		InputStreamReader将字节输入流转换为字符输入流；
		OutputStreamWriter将字节输出流转换成字符输出流。
	推回输入流（Begin51）：
		有PushbackInputStream和PushbackReader；
		这两个推回流都有一个推回缓冲区；
		当程序调用这两个推回流的unread()方法时，系统将会把指定数组的内容推回到该缓冲区中，
		而推回输入流每次调用read()方法时总会先从推回缓冲区读取，
		只有完全读取了推回缓冲区的内容后，但还没有装满read()所需的数组时才会从原输入流中读取。
	BufferedReader和BufferedWriter（Begin51）：
		BufferedReader由Reader类扩展而来，提供通用的缓冲方式文本读取，readLine读取一个文本行，
		从字符输入流中读取文本，缓冲各个字符，从而提供字符、数组和行的高效读取。
		BufferedWriter由Writer 类扩展而来，提供通用的缓冲方式文本写入， newLine使用平台自己的行分隔符，
		将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。
		缓冲区（缓冲区对应的类就是BufferedReader和BufferedWriter）：
		缓冲区的出现提高了对数据的读写效率；缓冲区要结合流才可以使用；在流的基础上对流的功能进行了增强；
		缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象；
		该缓冲区中提供了一个跨平台的换行符newLine();
		字符流缓冲区：该缓冲区提供了一次读一行的方法readLine，方便于对文本数据的获取，
			（readLine方法返回时只返回回车符之前的数据内容，并不返回回车符）；
			当返回空时表示读到了文件的末尾。
	FileInputStream和FileOutputStream（Begin51）：
		两个类的构造方法都需要指定文件的来源；
		FileInputStream从文件系统中的某个文件中获得输入字节，获取的文件可用性取决于主机环境；
		FileOutputStream向文件系统中的某个文件中获得输入字节，获取的文件可用性取决于主机环境。
	重定向标准输入输出（Begin53）：
		System.out：对应的是标准输出设备（控制台或屏幕）；
		System.in：对应的是标准输入设备（键盘）。
	RandomAccessFile（Begin54）：
		Java输入/输出流体系中功能最丰富的文件内容访问类；
		功能：1.读取文件；2.向文件输入数据；
		          3.支持随机访问（准确来说是任意访问）；4.可以向已有文件后面追加内容；
		缺陷：只能读写文件，不能读写其他IO节点；
		支持任一访问的原因：RandomAccessFile允许自由定位文件记录指针，
		而且RandomAccessFile对象也包含了一个记录指针用以标识当前读写的位置。
	对象序列化（Begin55）：
		对象序列化是什么（对象序列化的目标）：
			把对象保存在磁盘中，或允许在网络中直接传输对象；
			对象序列化允许把内存中的Java对象转换成平与台无关的二进制流，
			从而允许把这种二进制流持久的保存在磁盘上，
			通过网络将这种二进制流传输到另一个网络节点；
			其他程序一旦获得了这种二进制流（无论是从磁盘中获取还是从网络中获取），
			都可以将这种二进制流恢复成原来的Java对象。
		序列化机制允许将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或通过网络传输；
		序列化机制使得对象可以脱离程序而独立存在；
		对象的序列化是指将一个Java对象写入IO流中，对象的反序列化是指从IO流中恢复该Java对象；
		所有可能在网络上传输的对象的类都应该是可序列化的，否则程序将会出现异常。
		对象序列化的步骤：
			1、让类实现Serializable接口（这样这个类的对象就是可序列化的）；
			2、创建一个ObjectOutputStream输出流；
			3、调用ObjectOutputStream对象的writeObject()方法输出可序列化对象。
		反序列化的步骤：
			1、让类实现Serializable接口（这样这个类的对象就是可序列化的）；
			2、创建一个ObjectInputStream输入流；
			3、调用ObjectInputStream对象的readObject()方法读取流中的对象，
			该方法返回一个Object类型的Java对象（可强制转换成其他类型的对象）。
		对象引用的序列化：
		1.如果某个类的成员变量的类型不是基本类型或String类型，而是另一个引用类型，
		   则这个引用类必须是可序列化的，否则拥有该类型成员变量的类也是不可序列化的；
		2.Java序列化机制采用的序列化算法：
			1）.所有保存到磁盘中的对象都有一个序列化编号；
			2）.当程序序列化一个对象时，会先检查该对象是否已经被序列化过，只有在该对象没被序列化时，系统才会将该对象转换成字节序列并输出；
			3）.若某个对象已经序列化过，则程序只是输出一个序列化编号，而不是重新序列化该对象；
		3.这种机制存在的潜在问题：当程序序列化一个可变对象时，只有在第一次使用writeObject()方法输出时才会将该对象转换成字节序列并输出，
		   当该对象的实例变量已经被改变时，被改变的实例对象不会被输出；
		4.改善这种潜在问题的方法：
		自定义序列化（1）：实例变量被transient修饰；
			被transient修饰的实例变量不可被序列化；
			因此也出现了一个问题：反序列化恢复Java对象是无法取得该实例变量值；
		自定义序列化（2）：可以控制如何实例化各实例变量；
			写入特定类的实例状态，以便相应的readObject()可以恢复它，
			怎么自定义：
			通过重写该方法，程序员可以完全获得对序列化机制的控制，自主决定需要序列化哪些实例变量，以及如何序列化，
			private void writeObject(ObjectOutputStream out) throws IOException{}；
			从流中读取并恢复对象的实例化变量，
			通过重写该方法，程序员可以完全获得对反序列化机制的控制，自主决定需要反序列化哪些实例变量，以及如何进行反序列化，
			private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException{}；
		自定义序列化（3）：
			重写writeReplace方法，程序在序列化该对象之前，先调用该方法，
			private Object writeReplace() throws ObjectStreamException{}，
			此序列化机制在序列化对象时，实际上是转化为ArrayList对象；
		另一种自定义序列化机制：
			此种序列化机制完全由程序员决定存储和恢复对象数据；
			必须实现Externalizable接口。
			虽然实现Externalizable接口会带来一定的性能提升，但实现该接口导致编程的复杂度增加，
			所以大部分时候都采用实现Serializable接口的方式。
	IO异常的处理方式、异常的日志信息、Java虚拟机读取其他进程的数据（Begin57）
	文件锁（Begin57）：
		使用文件锁可以有效地阻止多个进程并发修改同一个文件；
		文件锁控制文件的全部或部分字节访问；
		lock()和tryLock()方法的区别：
		当lock()试图锁定某个文件时，如果无法得到文件锁，则程序将会一直阻塞，
		而tryLock()是尝试锁定文件，它将直接返回而不是阻塞，如果获得了文件锁，该方法返回文件锁，否则返回null。
		lock(long position, long size, boolean shared){}
		tryLock(long position, long size, boolean shared){}
		当shared为true时，表明该所是一个共享锁，它将允许多个进程来读取文件，但阻止其他进程获得对该文件的排他锁；
		当shared为false时，表明该所是一个排他锁，它将锁住对该文件的读写。
	【注】：
		计算机的文件常被分为文本文件和二进制文件两大类：
		所有能用记事本打开并看到其中字符内容的都是文本文件，反之则称为二进制文件。
28）类与对象（Begin7）：
	Person p = new Person();这句话都做了什么：
	1.因为new中用到了Person.class，所以会先找到Person.class文件并加载到内存
	2.执行该类中的static代码块，如果有的话，给Person.class类进行初始化
	3.在堆内存中开辟空间，分配内存地址
	4.在堆内存中建立对象得特有属性，并进行默认初始化
	5.对属性进行显性初始化
	6.对对象进行构造代码块初始化
	7.对对象进行对应的构造函数初始化
	8.将内存地址赋值给栈内存中的p变量
39）数据类型及运算符（Begin2）
30）循环（Begin3）
31）函数重载（Begin4）
32）进制转换（Begin6）
33）单例设计模式（Begin12）
34）装饰设计模式（MyBufferedReader1）
35）模板方法（Begin16）：
	在定义功能时，功能的一部分是确定的，但是有一部分是不确定的，而确定的部分在使用不确定的部分，
	那么这时就将不确定的部分暴露出去，由该类的子类去完成。
36）Date、Calendar、Math、System（Begin58）

		